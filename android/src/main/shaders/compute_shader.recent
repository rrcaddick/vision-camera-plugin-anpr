#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(std430, binding = 0) buffer YPlane {
    uint data[];
} yPlane;

layout(std430, binding = 3) buffer OutputBuffer {
    uint data[];
} outputBuffer;

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
    uint yStride;
} pushConstants;

void main() {
    uvec2 gid = gl_GlobalInvocationID.xy;

    // Ensure we're within the bounds of the output image (swapped dimensions)
    if (gid.x >= pushConstants.height || gid.y >= pushConstants.width) return;

    // Calculate the rotated coordinates in the input image (clockwise rotation)
    uint inputX = gid.y;
    uint inputY = pushConstants.height - 1 - gid.x;

    // Calculate the index into the Y plane based on the rotated coordinates
    uint yIndex = inputY * pushConstants.yStride + inputX;

    // Fetch the Y (luminance) value from the Y plane
    uint packedYValue = yPlane.data[yIndex / 4];
    uint shift = (yIndex % 4) * 8;
    uint yValue = (packedYValue >> shift) & 0xFF;

    // Calculate the index in the output buffer
    uint outputIndex = gid.y * pushConstants.height + gid.x;

    // Pack the Y value into the correct byte of the output uint
    uint outputPackedIndex = outputIndex / 4;
    uint outputShift = (outputIndex % 4) * 8;
    uint outputMask = 0xFF << outputShift;
    uint outputValue = (yValue << outputShift) & outputMask;

    // Use atomic operations to safely write to the packed uint in the output buffer
    atomicAnd(outputBuffer.data[outputPackedIndex], ~outputMask);
    atomicOr(outputBuffer.data[outputPackedIndex], outputValue);
}